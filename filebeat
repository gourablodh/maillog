filebeat.inputs:
  - type: log
    enabled: true
    paths:
      - /var/log/mail.log

    processors:

      # 1) Grab the common header: timestamp, hostname, component, pid, and leave the rest
      #    in `log.rest` for further parsing.
      - grok:
          match:
            # Use a single regex to capture the full ISO8601 timestamp, host, component, PID, and leftover text
            message: [
              '%{TIMESTAMP_ISO8601:log.timestamp} %{HOSTNAME:log.hostname} %{DATA:log.component}\[%{NUMBER:log.pid}\]: %{GREEDYDATA:log.rest}'
            ]
          ignore_missing: true
          ignore_failure: true

      # ────────────────────────────────────────────────────────────────────────────────
      # 2) PMG‐SMTP‐FILTER LINES (all of these only run when `log.component` contains "pmg-smtp-filter").
      #    a) “<MSGID>: accept mail to <RECEIVER> (QUEUE_ID) (rule: RULE_NAME)”
      #    b) “<MSGID>: processing time: 0.119 seconds (0, 0.043, 0)”
      #    c) “<MSGID>: SA score=0/5 time=1.914 hits=AWL(0.003), BAYES_00(-1.9), ...”
      - grok:
          when:
            contains:
              # Only match if the “component” extracted above has “pmg-smtp-filter” in it
              log.component: "pmg-smtp-filter"
          match:
            # 2a) Accept mail lines: capture message_id, receiver, queue_id, rule
            log.rest: [
              '%{WORD:log.message_id}: accept mail to <%{DATA:log.receiver}> \(%{WORD:log.queue_id}\) \(rule: %{DATA:log.rule}\)'
            ]
          ignore_missing: true
          ignore_failure: true

      - grok:
          when:
            contains:
              log.component: "pmg-smtp-filter"
          match:
            # 2b) Processing time lines: capture message_id, proc_seconds, proc_breakdown
            log.rest: [
              '%{WORD:log.message_id}: processing time: %{NUMBER:log.proc_seconds} seconds \(%{GREEDYDATA:log.proc_breakdown}\)'
            ]
          ignore_missing: true
          ignore_failure: true

      - grok:
          when:
            contains:
              log.component: "pmg-smtp-filter"
          match:
            # 2c) SA score lines: capture message_id, sa_score, sa_threshold, sa_time, sa_hits
            log.rest: [
              '%{WORD:log.message_id}: SA score=%{NUMBER:log.sa_score}/%{NUMBER:log.sa_threshold} time=%{NUMBER:log.sa_time} %{GREEDYDATA:log.sa_hits}'
            ]
          ignore_missing: true
          ignore_failure: true

 
          when:
            contains:
              log.component: "postfix"
          match:
            log.rest: [
              # (3a) From lines
              '%{WORD:log.queue_id}: from=<%{EMAIL:log.sender}>, size=%{NUMBER:log.size}, nrcpt=%{NUMBER:log.nrcpt} \(%{DATA:log.queue_status}\)',

              # (3b) Delivery lines with both to AND relay/status
              '%{WORD:log.queue_id}: to=<%{EMAIL:log.receiver}>, relay=%{DATA:log.relay}\[%{IP:log.relay_ip}\]:%{NUMBER:log.relay_port}, delay=%{NUMBER:log.delay}, delays=%{DATA:log.delays}, dsn=%{DATA:log.dsn}, status=%{WORD:log.status} \(%{GREEDYDATA:log.status_msg}\)',

              # (3c) Removed lines
              '%{WORD:log.queue_id}: removed',

              # (3d) Cleanup lines with message‐ID
              '%{WORD:log.queue_id}: message-id=<%{DATA:log.message_id}>',

              # (3e) Hostname warning lines
              'warning: hostname %{DATA:log.warn_host} does not resolve to address %{IP:log.warn_ip}: %{GREEDYDATA:log.warn_message}',

              # (3f) Trusted TLS lines
              'Trusted TLS connection established to %{DATA:log.tls_remote_host} \[%{IP:log.tls_ip}\]:%{NUMBER:log.tls_port}: %{GREEDYDATA:log.tls_details}',

              # (3g) Connect lines
              'connect from %{DATA:log.client_host} \[%{IP:log.client_ip}\]',

              # (3h) Disconnect lines
              'disconnect from %{DATA:log.client_host} \[%{IP:log.client_ip}\] %{GREEDYDATA:log.disconnect_details}',

              # (3i) Qmgr “client=” lines
              '%{WORD:log.queue_id}: client=%{DATA:log.client_host} \[%{IP:log.client_ip}\]'
            ]
          ignore_missing: true
          ignore_failure: true

      # ────────────────────────────────────────────────────────────────────────────────
      # 4) POSTFIX/POSTSCREEN LINES (exactly when component is "postfix/postscreen"):
      #    a) “CONNECT from [<IP>]:<PORT> to [<IP>]:<PORT>”
      #    b) “PASS OLD [<IP>]:<PORT>”
      - grok:
          when:
            contains:
              log.component: "postfix/postscreen"
          match:
            log.rest: [
              # (4a) CONNECT lines
              'CONNECT from \[%{IP:log.ps_client_ip}\]:%{NUMBER:log.ps_client_port} to \[%{IP:log.ps_server_ip}\]:%{NUMBER:log.ps_server_port}',

              # (4b) PASS OLD lines
              'PASS OLD \[%{IP:log.ps_client_ip}\]:%{NUMBER:log.ps_client_port}'
            ]
          ignore_missing: true
          ignore_failure: true

      # ────────────────────────────────────────────────────────────────────────────────
      # 5) POSTFIX/SCACHE STATISTICS LINES (component = "postfix/scache"):
      #    a) “statistics: start interval May 17 23:51:57”
      #    b) “statistics: domain lookup hits=0 miss=2561 success=0%”
      #    c) “statistics: address lookup hits=0 miss=3981 success=0%”
      - grok:
          when:
            contains:
              log.component: "postfix/scache"
          match:
            log.rest: [
              # (5a) Interval start
              'statistics: start interval %{GREEDYDATA:log.scache_interval}',

              # (5b) Domain lookup
              'statistics: domain lookup hits=%{NUMBER:log.domain_hits} miss=%{NUMBER:log.domain_miss} success=%{NUMBER:log.domain_success}%%',

              # (5c) Address lookup
              'statistics: address lookup hits=%{NUMBER:log.address_hits} miss=%{NUMBER:log.address_miss} success=%{NUMBER:log.address_success}%%'
            ]
          ignore_missing: true
          ignore_failure: true

      # ────────────────────────────────────────────────────────────────────────────────
      # 6) PMGPOLICY LINES (component contains "pmgpolicy"):
      #    a) “Received a SIG HUP”
      #    b) Any other free‐form policy message
      - grok:
          when:
            contains:
              log.component: "pmgpolicy"
          match:
            log.rest: [
              # (6a) Exact SIG HUP
              'Received a SIG HUP',

              # (6b) Fallback: capture anything else as a policy_message
              '%{GREEDYDATA:log.policy_message}'
            ]
          ignore_missing: true
          ignore_failure: true

      # ────────────────────────────────────────────────────────────────────────────────
      # 7) Keep the original full message in log.original (for debugging/fallback)
      - rename:
          fields:
            - from: "message"
              to:   "log.original"

      # ────────────────────────────────────────────────────────────────────────────────
      # 8) Finally, drop any unneeded leftover fields. At this point, all relevant
      #    bits are under log.*; we can remove log.rest and the raw message.
      - drop_fields:
          fields:
            - "log.rest"
            - "message"
